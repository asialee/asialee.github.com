---
layout: post
title: C/C++下void*类型指针介绍
keywords: c++ void
categories: [C]
tag: [C,C++]
icon: code
---

写C/C++程序经常会遇到void*类型的指针，以前对于这种指针没有去深究，只要程序可以正常运行就得过且过了，今天在网上搜了一些资料，才算是对这个void*类型指针有了更多的认识。

void*顾名思义就是不指向任何对象的指针，也被称为通用指针或者是泛型指针。也是C语言下“纯粹地址”（raw address）的一种约定。void*仅仅指示一个地址，但是因为其不指向任何类型的对象，所以当得到一个void*类型指针指向的一段内存时，并不能直接使用void*指针对该内存进行操作，而必须用相应的类型指针来操作：比如该段内存时一段字符串，那么可以用char*来进行操作。

之所以设计出void*这种类型的指针，设计者的主要思路我想估计有一下这么两个：

- 对函数返回值以及参数的限制
- 方便通用函数的设计
- 方便内存操作

#对函数返回值以及参数的限制#

在c/c++下申明的函数如果没有返回值，那么就必须将其的返回类型设置为void，这是因为如果不标明其返回类型，那么编译器会默认其返回类型是int，所以需要用void来进行限定。
另外就是在c++下，如果向一个没有参数的函数传入参数时，编译器会报错，这也是因为该函数的参数的void。

#方便通用函数的设计#

如果一个函数是针对各种类型的数据都适用的时候，这个时候就应该适用void*类型作为参数，因为首先void*类型的指针可以转换为各种类型的指针，然后再针对这些具体类型做进一步操作。当然很多人会说，其实传入char*指针也可以实现这种功能。确实可以，但是这样会造成不必要的误会，让用户以为这个函数只能对字符串进行处理，而不是适用各种函数。
我们经常使用到的内存复制和赋值函数就都是以void*为指针：

{% highlight C++ %}
void * memcpy(void *dest, const void *src, size_t len);   
void * memset ( void * buffer, int c, size_t num ); 
{% endhighlight %}

#方便内存操作#

void*指针最重要的的作用我想还是进行内存操作。一段内存里可能含有各种不同数据类型，如果要将一段内存共享或者发送给其他主机时，以void*类型的指针来代表该段内存是最好的选择。

{% highlight C++ %}
void * memcpy(void *dest, const void *src, size_t len);   
void * memset ( void * buffer, int c, size_t num );
{% endhighlight %}

还是以这两个函数为例，这两个函数都涉及到内存操作，都无一例外地使用void*类型作为参数类型也证明了这一点。值得注意的是，在传入一个void*类型的指针的时候，通常还需要传入一个int型的参数作为该段内存的大小，如以上两个函数的len和num，这里的len和num指示的长度是byte。虽然在void*不支持任何数学操作，但是一个void对象其实和char一样，代表一个byte。


